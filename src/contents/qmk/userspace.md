---
datetime: 2023-06-05T15:00:00Z
title: "Userspace documentation #QMK"
featured: true
tags:
- qmk
ogImage: ""
---

---
# ‚ö†Ô∏è NOTE ‚ö†Ô∏è

*Bear in mind, any code/explanation here may not be up to date with the current state of my repo when reading this. However, filenames and locations shouldn't change much and should remain easy to find. New functionality will be added but may not be documented, things explained below (most likely) won't be removed but chances are they get moved around, though.*

If you are reading this, you probably know already, but code using these features can be found on my [qmk_build](https://github.com/elpekenin/qmk_build) repository.
  * Most stuff is under `users/elpekenin`
  * See `access.json` to see how the compilation of my code is setup (`src` contains the source for my custom build-tool)

## *Last update: 24-Oct-2023*
---

# Index

# Quantum Painter (from now on, "*QP*")
## Drawing, and some helpers: `graphics.h`
### All assets available dynamically
See [here](#2-auto-include-assets-qp_resourcesh)

### Programmatic access to resources (instead of variables)
  * API for loading (`load_display`, `load_font` and `load_image`) will:
    * Load fonts/images into RAM, using QP's API (`qp_load_*_mem`)
    * Save these resources into arrays
      * `qp_devices_pekenin` (avoid name collision with `qp_internal.c`)
      * `qp_fonts`
      * `qp_images`
    * Print (if QP_DEBUG is enabled) the name of the asset being loaded.
      <div style="padding-left:30px" /> Eg: "Loading ili9163 at position [0]"
  * API for information (`num_displays`, `num_fonts` and `num_imgs`)
  * No API for getting them, just use `qp_fonts[0]` or the like.


### Scrolling text API ‚ú®
<span style="margin-right: 30%"></span>üî¥Uses `malloc`, `realloc` and `free`üî¥

Using `defer_exec` to draw moving strings, similar to `qp_animate`. 

**<u>Note</u>:** The state (`scrolling_text_state_t`) contains the amount of spaces to draw before repeating the string, this is currently not part of the API and gets a hardcoded value on the function's body.

  * Create a new scrolling text
  ```c
  // API is very similar to qp_drawtext[_recolor] but also takes the amount of chars to write each time, and delay between steps

  deferred_token draw_scrolling_text(painter_device_t device, uint16_t x, uint16_t y, painter_font_handle_t font, const char *str, uint8_t n_chars, uint32_t delay);

  deferred_token draw_scrolling_text_recolor(painter_device_t device, uint16_t x, uint16_t y, painter_font_handle_t font, const char *str, uint8_t n_chars, uint32_t delay, uint8_t hue_fg, uint8_t sat_fg, uint8_t val_fg, uint8_t hue_bg, uint8_t sat_bg, uint8_t val_bg);
  ``` 
  * Make a task's text longer (mainly meant for drawing long strings over XAP):
  ```c
  void extend_scrolling_text(deferred_token scrolling_token, const char *str);
  ```
  * Cancel a running task
  ```c
  void stop_scrolling_text(deferred_token scrolling_token);
  ```

### Small drawing functions
There are some other functionalities here:
  - Small code to compute days, hours, minutes, seconds from `timer_read32` and drawing them on a screen (not broken into a function)
  - This function does what its name suggests, based on [#19542](https://github.com/qmk/qmk_firmware/pull/19542)
  ```c
  void draw_commit(painter_device_t device);
  ```
  - This one iterates over [`enabled_features_t`](#user_featuresh) to draw its contents. Its body is generated by [features.py](#enabled-features-featurespy)
  ```c
  void draw_features(painter_device_t device);
  ```
  
These last two functions will show latest information on slave side (without reflashing it) thanks to [data sync](#user_transactionsh) 
   
Output:
  
  ![](/content-images/qmk/features_draw.png)

## Custom `print` implementation: `user_logging.h`
Inspired on @tzarc's work, this replaces the function called by `print` to render each `char` with a custom implementation.

On this tweaked version:
  * If QP is enabled, we keep track of logging messages on a buffer to then draw them on a display. I extended @tzarc's functionality by allowing longer lines to be stored and drawing them (when needed) with my [`scrolling texts API`](#scrolling-text-api-‚ú®)
  * If XAP is enabled, send logging over it. [XAP's Log specification](https://github.com/qmk/qmk_firmware/blob/xap/docs/xap_0.3.0.md#log-message---0x00)
  * Maintain the implementation provided by QMK (`sendchar`) which will be a no-op or Console endpoint if said feature is enabled.

### Logging on screen (`qp_logging.h`)
The actual drawing takes place on `graphics.c`, this file simply keeps track of the text.

Usage:
  1. Configure the buffer size (or don't, and fallback to my default values)
  ```c
  #define LOG_N_LINES <Number>
  #define LOG_N_CHARS <Number>
  ```
  2. Determine the screen where to draw
  ```c
  qp_log_target_device = <your_device>;
  ```
  

## QGF-converted database (and scripts)
If you want some pre-converted QGF images, I have a collection of Material Design Icons (and the scripts to mass-convert folders) in [this repo](https://github.com/elpekenin/mdi-icons-qgf)

---

# XAP

In case you haven't heard of it, this is a Work In Progress feature aimed for bidirectional communication between your keyboard and PC, you can track it on [PR#13733](https://github.com/qmk/qmk_firmware/pull/13733), and its documentation can be found on that same branch (`xap`) of the repo, under the `docs` folder.

## Draw from the PC: `qp_over_xap.h`
XAP bindings that expose display-related functions over XAP.

Messages' definition can be found at `xap.hjson`

Usage:
  1. Will automatically get added if you have both XAP and Quantum Painter enabled
  2. You can disable it, even if both features are enabled
  ```makefile
  # rules.mk
  # --------
  QP_XAP = no
  ```
  3. Code relies on having the assets in the arrays mentioned on [Quantum Painter - Macros](#macros)
  4. Send XAP messages from PC to execute this code. [Here](https://github.com/elpekenin/qmk_xap) is my fork of [qmk_xap](https://github.com/qmk/qmk_xap) (which is official QMK's XAP client)

## Send info to the PC: `user_xap.h`
Helper functions to send information about some events to the XAP client, such as:
  * Rebooting the board or jumping to bootloader
  * Key events (presses/released) which could be used to make usage stats
  * [Touch screen](#touch_driverh) state

---

# Codegen
Generate **C** code from **Python** scripts that get run during compilation.

These features are not (yet?) configured via `rules.mk`, thus can't easily be disabled (you'd need to tweak the Makefile yourself).

## 1. Enabled features: `features.py`
Defines `enabled_features_t` which is a struct containing whether some features are enabled on this compilation or not.

Usage:
  1. Tweak its configuration (if you want to) at the very top of the script
    * Add or remove elements from `FEATURES` to modify which of them are tracked
    * Use `SHORT_NAMES` to define aliases. Note: These are only used on the `draw_features` function, not on the `struct`'s attributes names
  2. Read the state
  ```c
  enabled_features_t get_enabled_features(void);
  ```
  3. Check a particular feature. Note: all names are `lower_snake_case`.
  ```c
  if (features.rgb_matrix) {
      printf("RGB Matrix is enabled!\n");
  }
  ```

## 2. Auto-include assets: `qp_resources.py`
Creates:
  * `generated_qp_resources.h`, header that `#include`'s all QGF/QFF files found, and gets `#include`'d by `graphics.h`
  * `generated_qp_resouces.c`, defines `load_qp_resources` which calls `load_font` and `load_image` [macros](#macros) on every asset found
  * `generated_qp_resources.mk` which has the `SRC +=` lines for them

Usage: Code will locate your files at `painter/fonts` and `painter/images` on the keyboard, keymap, and userspace folders. No need to configure anything

## 3. Keycode names: `keycode_str.py`
‚ö†Ô∏è Does not currently support `.json` keymaps

Parses your keymap file (based on `KEYMAP_PATH` variable), finding the keycodes you've mapped on your layers, providing:
```c
const char *get_keycode_str_at(uint8_t layer, uint8_t row, uint8_t col)
``` 
Which will return `"KC_A"` for the positon where you had `KC_A` and so on. I.e. stringification of the keymap contents.

---

# Touchscreens: `touch_driver.h`
Custom code to interact with my XPT2046-based touchscreen modules, the code is designed such that other SPI sensors should be somewhat easy to integrate. 

This code does the bare minimum, **reads the sensor**.

Feel free to elaborate on that information: compute movements (even integrate on pointing device), detect gestures from those movements, etc. This is left as an exercise for the reader.

Usage:
  1. Enable it
  ```makefile
  # rules.mk
  # --------
  TOUCH_SCREEN = yes
  ```
  2. Configure a `touch_driver_t` according to your sensor, mine is:
  ```c
  static const touch_driver_t ili9341_touch_driver = {
      .width = _ILI9341_WIDTH,
      .height = _ILI9341_HEIGHT,
      .scale_x = 0.07,
      .scale_y = -0.09,
      .offset_x = -26,
      .offset_y = 345,
      .rotation = (ILI9341_ROTATION + 2) % 4,
      .upside_down = false,
      .spi_config = {
          .chip_select_pin = ILI9341_TOUCH_CS_PIN,
          .divisor = TOUCH_SPI_DIV,
          .lsb_first = false,
          .mode = TOUCH_SPI_MODE,
          .irq_pin = NO_PIN,
          .x_cmd = 0xD0,
          .y_cmd = 0x90
      },
  };
  touch_device_t ili9341_touch = &ili9341_touch_driver;
  ```
  3. Initialize it
  ```c
  touch_spi_init(ili9341_touch);
  ```
  4. Read
  ```c
  touch_report_t ili9341_touch_report = get_spi_touch_report(ili9341_touch, false);
  ```

  ### Note
   `scale` and `offset` values are used to calibrate the display. Reading does some mats for both coords
  ```c
  coord = (scale * raw_reading) + offset;
  ```
  With these arguments you should be able to map whichever range of values the raw data is, to: `(0, 0) - (width, height)`

  There is no code or explanation on how to do this, I simply checked what the raw data was on each of the 4 corners, to locate the two that got read as `(small_x, small_y)` and `(big_x, big_y)` discarding `(big_x, small_y)` and `(small_x, big_y)`. With these two corners i took the average of 3-5 readings and made a lineal adjustment to scale them down to the size of my display.

---

# Multi-bus SPI: `custom_spi_master.h`
"Small" changes to QMK's built-in SPI driver (abstractions over `ChibiOS`'s functions), so that we can use multiple SPI instances at the same time.

---

# "Virtual pins" to control several signals: `sipo_pins.h`
A set of macros and functions that allow using SerialIn-ParallelOut shift registers (supports daisy chaining) to control several "virtual GPIO". With this, you can generate an arbitrary amount of output signals using 3 GPIOs on the MCU (SCK, MOSI, CS).

My use-case for this is driving a multi-screen setup with fewer pins. This requires:
- [custom_spi_master](#custom_spi_masterh): one bus is used for the displays and the second one for the registers. This way, we can change CS/DC signals while talking to the display without messing communications up due to sending data on that bus.
- Patches to `qp_comms_spi.c` (or manually creating a new vtable with tons of duplication), to use the multi-bus driver instead of QMK's built-in `spi_master.h`. This code uses "tradicional" names, like `SPI_SCK_PIN`, for the screens, while the register ones prepend `REGISTER_` to them. Then arrays are created combining the two, where position(id) 0 belongs to screens and 1 to registers.

Usage:
  1. Enable it
  ```makefile
  # rules.mk
  # --------
  SIPO_PINS = yes
  ```
  2. Configure the amount of pins you will use, to allocate a buffer accordingly
  ```c
  #define N_SIPO_PINS <Number>
  ```
  3. Create your "pin" name(s) -- This is a macro, place it outside any function
  ```c
  configure_sipo_pins(<NAME_1>, <NAME_2>, ...);
  ```
  4. Control pin state
  ```c
  // Change status in buffer
  set_sipo_pin(<pin_name>, <value>);

  // Aliases
  sipo_buffer_high(<pin_name>);
  sipo_buffer_low(<pin_name>);

  // Flush state
  send_sipo_state();

  // Change state and flush it
  sipo_write_high(<pin_name>);
  sipo_write_low(<pin_name>); 
  ```

---

# Split messaging: `user_transactions.h`
Sends a `user_data_t` struct over split comms, to sync **some** information/configuration without needing to reflash slave side 
```c
// gets called upon receiving a message on slave side, to store its content
void user_data_sync_slave(uint8_t m2s_size, const void* m2s_buffer, uint8_t s2m_size, void* s2m_buffer);
// you can also define this, to run extra logic on receptions
void user_data_sync_keymap_callback(void);

// sends messages to slave periodically
void split_sync_housekeeping(uint32_t now);

// configuration needed for transactions
void transactions_init(void);
```
---

# Keylogger: `user_keylog.h`
Inspired by @drashna's code, this provides a way of storing/showing recent presses as a string. Obviously, depends on [`get_keycode_str_at`](#3-keycode-names-keycode_strpy)

Usage:
  1. Enable it
  ```makefile
  # rules.mk
  # --------
  KEYLOG_ENABLE = yes
  ```

  2. `keylog_process` will be called for processing after a key is pressed/released. APIs on this file for
     - "Prettifying" string (original isn't modified, the pointer is now looking somewhere else)
     ```c
     // eg a pointer to "KC_A" would now point to "A"
     void remove_prefixes(char **str);

     // eg change "KC_LEFT" becomes "‚Üê"
     void replace_symbols(char **str);
     // iterates over an array of
     #define REPLACE(<input>, <output>)

     // same, but for shifted symbols
     void replace_mods(char **str);
     #define MOD_REPLACE(<input>, <output>, <mod_mask>)
     #define REPLACE_ALGR(<input>, <output>)
     #define REPLACE_SFT(<input>, <output>)

     // convert to lowercase based on caps and shift
     void apply_casing(char **str);
     ```

     - Updating the log (buffer)
     ```c
     void keylog_clear(void);

     // clear last element, aka: when backspace
     void keylog_shift_right(void);

     // add an element to the end
     void keylog_append(char *str);

     ```

  3. My code will also change the log's color based on WPM(if enabled), you can tweak the colors (or completely get rid of them) and the WPM values at which they change by editing `graphics.c`. I didn't setup any `#define` for this 

Congratz!
![](/content-images/qmk/keylog.jpg)


TODO: `user_rgb_matrix_indicators` documentation

<!-- # One Hand Mode (**abandoned right now**)
The goal for this feature is to add a new *RGB Matrix* animation which only lights a single LED, used as a "marker" so that you can then virtually press the selected key. This will allow for accessibility, because the direction in which the LED moves and the trigger of the press is completely customizable (code does just the bare minimum), thus you can change which events trigger moving around and pressing, eg using different pointing devices, or a set of keys(arrows).

Usage:
 - Add `ONE_HAND = yes` to your **rules.mk** -->