---
datetime: 2023-06-05T15:00:00Z
title: "Userspace documentation #QMK"
featured: true
tags:
- qmk
ogImage: ""
---

---
# ‚ö†Ô∏è NOTE ‚ö†Ô∏è

*Any code/explanation in here may not be updated with the current state of my repo whenever you read this, bear that in mind. However, file names/location shouldn't change much and should be easy to find. Code-wise, chances are stuff is added without removing (**but perhaps moving**) the functionality explained here.*

If you are reading this, you probably know already, but just in case: The code can be found at the `pekelop` branch of my fork [here](https://github.com/elpekenin/qmk_firmware/tree/pekelop/users/elpekenin)

Code using these features can be found at the userspace itself, my [custom keyboard](https://github.com/elpekenin/qmk_firmware/tree/pekelop/keyboards/elpekenin/access) and my [keymap](https://github.com/elpekenin/qmk_firmware/tree/pekelop/keyboards/elpekenin/access/keymaps/elpekenin) for it

---

# Index

# Quantum Painter
## üöß Auto-include assets
TODO: Move to a scripts outside of CLI and document it

## Drawing, and some helpers: `graphics.h`
### Macros
`load_display`, `load_font` and `load_image` which:
  * Load the assets into RAM, using QP's API
  * Save them on arrays (`qp_devices_pekenin` - avoid name collision with `qp_internal.c`, `qp_fonts`, `qp_images`), as a common place to find everything
  * Print (if QP_DEBUG is enabled) the name of the asset being loaded.

     <div style="padding-left:30px" /> Eg: "Loading ili9163 at position [0]"

### Scrolling text API ‚ú®
Using `defer_exec` to draw moving strings, similar to `qp_animate`. 

üî¥Uses `malloc`, `realloc` and `free`üî¥ to keep a copy of the string, because original text could be dropped while this is running.

**<u>Note</u>:** The state (`scrolling_text_state_t`) contains the amount of spaces to draw before repeating the string, this is currently not exposed and gets a hardcoded value on the function's body.

  * Create a new scrolling text with `draw_scrolling_text` (or its `_recolor`) counterpart
    - Similar to `qp_drawtext` but also takes the amount of chars to be drawn each step and the delay between them.
    - Returns a token that identifies this task and is used by the rest of the API

  * Extend an existing task's text (mainly meant for drawing long strings this over XAP): `extend_scrolling_text`
  * `stop_scrolling_text` to cancel a running task

### Small drawing functions
There are some smaller functions here:
  - Small code to compute days, hours, minutes, seconds from `timer_read32` and drawing them on a screen
  - `draw_commit` does what its name says, based on `version.h`. PR'ed this on [#19542](https://github.com/qmk/qmk_firmware/pull/19542)
  - `draw_features` iterates over [`enabled_features_t`](#user_featuresh) to draw its contents. Both of these functions will show latest information when called from slave side (without needing a reflash) using [data sync](#user_transactionsh), the fucntion's body is generated by [features.py](#enabled-features-featurespy). 
   
    Output:
  
  ![](/content-images/qmk/features_draw.png)

## `print` on your screens: `qp_logging.h`
Again, based on @tzarc's work, this replaces the built-in function called by the implementation of `print` under the hood to render each `char`. On this tweaked version, we maintain the default send-over-USB behaviour, but also keep track of it on a buffer to later draw on a display. I extended his work allowing longer lines to be stored and drawing it with my [`scrolling API`](#scrolling-text-api-‚ú®)

The actual drawing takes place on `graphics.c`, this file simply keeps track of the text.

Usage:
  1. Configure the buffer size (or don't, and fallback to my default values)
  ```c
  #define LOG_N_LINES <Number>
  #define LOG_N_CHARS <Number>
  ```
  2. Determine the screen where to draw
  ```c
  qp_log_target_device = <your_device>;`
  ```
  

## QGF-converted database (and scripts)
If you want some pre-converted QGF images, I have a collection of Material Design Icons (and the scripts to generate them from folders) in [this repo](https://github.com/elpekenin/mdi-icons-qgf)

---

# XAP
## Draw from the PC: `qp_over_xap.h`
XAP bindings that expose display-related functions over XAP.

Messages' definition can be found at `xap.hjson`

Usage:
 1. Will automatically get added if you have both XAP and Quantum Painter enabled
 2. You can disable it, even if both features are enabled, by adding `QP_XAP = no`
 3. Selecting a display, font or image relies on having the assets loaded, as explained on [Quantum Painter - Macros](#macros)
 4. Send messages over XAP, to execute this code. [My fork of qmk_xap](https://github.com/elpekenin/qmk_xap)

## Send info to the PC: `user_xap.h`
Helper functions to send information about some events to the XAP client, such as reboot/bootload, keys being pressed or released (could make some usage stats), or [touch screen](#touch_driverh)'s state.

---

# Codegen
Generate **C** code from **Python** `/scripts` that get run during compilation.

## Enabled features: `features.py`
Defines `enabled_features_t` which is a struct that contains whether some features where enabled on this compilation or not.

Usage:
  1. Tweak its configuration (if you want to) at the very top of the script
    * Add or remove elements from `FEATURES` to modify which of them are checked by the script 
    * Use `SHORT_NAMES` to define aliases (these are only used on the `draw_features` function, not on the `struct`'s attributes names)
  2. Read the values with
  ```c
  enabled_features_t get_enabled_features(void);
  ```
  3. Read state of a particular feature (note: all names are `lower_snake_case`)
  ```c
  if (features.rgb_matrix) {
      printf("RGB Matrix is enabled!\n");
  }
  ```
---

# Touchscreens: `touch_driver.h`
Custom code to interact with my XPT2046-based touchscreen modules, the code is designed such that other SPI sensors should be somewhat easy to integrate. 

This code does the bare minimum, **reads the sensor**.

Feel free to elaborate on that information: compute movements (even integrate on pointing device), detect gestures from those movements, etc. This is left as an exercise for the reader.

Usage:
  1. Add `TOUCH_SCREEN = yes` to your **rules.mk**
  2. Configure a `touch_driver_t` according to your sensor, for example my config is:
  ```c
  static const touch_driver_t ili9341_touch_driver = {
      .width = _ILI9341_WIDTH,
      .height = _ILI9341_HEIGHT,
      .scale_x = 0.07,
      .scale_y = -0.09,
      .offset_x = -26,
      .offset_y = 345,
      .rotation = (ILI9341_ROTATION + 2) % 4,
      .upside_down = false,
      .spi_config = {
          .chip_select_pin = ILI9341_TOUCH_CS_PIN,
          .divisor = TOUCH_SPI_DIV,
          .lsb_first = false,
          .mode = TOUCH_SPI_MODE,
          .irq_pin = NO_PIN,
          .x_cmd = 0xD0,
          .y_cmd = 0x90
      },
  };
  touch_device_t ili9341_touch = &ili9341_touch_driver;
  ```
  3. Initialize it
  ```c
  touch_spi_init(ili9341_touch);
  ```
  4. Read
  ```c
  touch_report_t ili9341_touch_report = get_spi_touch_report(ili9341_touch, false);
  ```

  **Note**: `scale` and `offset` values are used to calibrate the display. Reading does some mats for both coords
  ```c
  coord = (scale * raw_reading) + offset;
  ```
  With these arguments you should be able to map whichever range of values the raw data is, to: `(0, 0) - (width, height)`

  There is no code or explanation on how to do this, I simply checked what the raw data was on each of the 4 corners, to locate the two that got read as `(small_x, small_y)` and `(big_x, big_y)` discarding `(big_x, small_y)` and `(small_x, big_y)`. With these two corners i took the average of 3-5 readings and made a lineal adjustment to scale them down to the size of my display.

---

# Multi-bus SPI: `custom_spi_master.h`
"Small" changes to QMK's built-in SPI driver (abstractions over `ChibiOS`'s functions), so that we can use multiple SPI instances at the same time.

---

# "Virtual pins" to control several signals: `sipo_pins.h`
A set of macros and functions that allow using SerialIn-ParallelOut shift registers (supports daisy chaining) to control several "virtual GPIO". With this, you can generate an arbitrary amount of output signals using 3 GPIOs on the MCU (SCK, MOSI, CS).

My use-case for this is driving a multi-screen setup with fewer pins. This requires:
- [custom_spi_master](#custom_spi_masterh): one bus is used for the displays and the second one for the registers. This way, we can change CS/DC signals while talking to the display without messing communications up due to sending data on that bus.
- Patches to `qp_comms_spi.c` (or manually creating a new vtable with tons of duplication), to use the multi-bus driver instead of QMK's built-in `spi_master.h`. This code uses "tradicional" names, like `SPI_SCK_PIN`, for the screens, while the register ones prepend `REGISTER_` to them. Then arrays are created combining the two, where position(id) 0 belongs to screens and 1 to registers.

Usage:
  1. Add `SIPO_PINS = yes` to your **rules.mk**
  2. Configure the amount of pins you will use, to allocate a buffer accordingly
  ```c
  #define N_SIPO_PINS <Number>
  ```
  3. Create your "pin" name(s)
  ```c
  configure_sipo_pins(<NAME_1>, <NAME_2>, ...);
  ```
  4. Control pin state
  ```c
  // Change status in buffer
  set_sipo_pin(<pin_name>, <value>);

  // Aliases
  sipo_buffer_high(<pin_name>);
  sipo_buffer_low(<pin_name>);

  // Flush state
  send_sipo_state();

  // Change state and flush it
  sipo_write_high(<pin_name>);
  sipo_write_low(<pin_name>); 
  ```

---

# Split messaging: `user_transactions.h`
Sends a `user_data_t` struct over split comms, to sync **some** information/configuration without needing to reflash slave side 
```c
// get called upon receiving a message on slave side, to store its content
void user_data_sync_slave(uint8_t m2s_size, const void* m2s_buffer, uint8_t s2m_size, void* s2m_buffer);

// you can also define this, to run extra logic on receptions
void user_data_sync_keymap_callback(void);
```
```c
// sends a message to slave every now and then
void split_sync_housekeeping(uint32_t now);
```
```c
// configuration needed for transactions
void transactions_init(void);
```
---

# Keylogger: `user_keylog.h`
Inspired by @drashna's code, and the `gboard` combo management, this file uses some pre-processor magic to stringify the keymap's content and get the string representation of each key. It also provides functions and macros to replace strings, eg: `"KC_SPC"` -> `" "`, this supports unicode too!!

Usage:
  1. Move your content to a new file, `layers.h`, which will be processed ***magically***

  For example
  ```c
  const uint16_t PROGMEM keymaps[][MATRIX_ROWS][MATRIX_COLS] = {
      [_BASE] = LAYOUT(KC_A, KC_B)
  };
  ```
  Would become
  ```c
  // layers.h
  // --------
  // note: in the same way as LAYOUT macro, the newlines/whitespaces dont matter here
  //       however it seems easier to read after splitting keys from layer name
  LAYER(_BASE,
      KC_A, KC_B
  )

  // keymap.c
  // --------
  // i know this is gross ...
  #undef LAYER
  #define LAYER(layer_name, ...) [layer_name] = LAYOUT(__VA_ARGS__),
  const uint16_t PROGMEM keymaps[][MATRIX_ROWS][MATRIX_COLS] = {
      #include KEYMAP_LAYERS_H
  };
  ```

  2. In that same file, add a dummy layer which will be used to map row/col positions to the order in which you write the keys in the macro (and vice-versa)

  For our example, that would be: 
  ```c
  // beware, counting starts at 1
  __DUMMY_LAYER(1, 2) 
  ```

  3. Configure the `KEYMAP_LAYERS_H` variable, used to locate the `layers.h` file. For me this was it:
  ```makefile
  # makefile variable
  KEYMAP_LAYERS_H = keyboards/elpekenin/access/keymaps/elpekenin/layers.h

  # equivalent pre-processor macro/define
  OPT_DEFS += -DKEYMAP_LAYERS_H=\"$(KEYMAP_LAYERS_H)\"
  ```

  4. You can now get the name of a particular keycode with
  ```c
  char *get_keycode_str_at(uint8_t layer_num, uint8_t row, uint8_t column);
  ```

  5. With that function, you can do any processing after a key is pressed/released.
     - Functios to pretify string (original isn't modified, the pointer is now looking somewhere else)
     ```c
     // eg a pointer to "KC_A" would now point to "A"
     void remove_prefixes(char **str);

     // eg change "KC_LEFT" becomes "‚Üê"
     void replace_symbols(char **str);
     // iterates over an array of
     #define REPLACE(<input>, <output>)

     // same, but for shifted symbols
     void replace_mods(char **str);
     #define MOD_REPLACE(<input>, <output>, <mod_mask>)
     #define REPLACE_ALGR(<input>, <output>)
     #define REPLACE_SFT(<input>, <output>)

     // convert to lowercase based on caps and shift
     void apply_casing(char **str);
     ```

     - Functions to update the log (buffer)
     ```c
     void keylog_clear(void);

     // clear last element, aka: when backspace
     void keylog_shift_right(void);

     // add an element to the end
     void keylog_append(char *str);

     ```

     - Handle key events
     ```c
     void keylog_process(uint16_t keycode, keyrecord_t *record) {
     ```

Congratz!
![](/content-images/qmk/keylog.jpg)


<!-- # One Hand Mode (**abandoned right now**)
The goal for this feature is to add a new *RGB Matrix* animation which only lights a single LED, used as a "marker" so that you can then virtually press the selected key. This will allow for accessibility, because the direction in which the LED moves and the trigger of the press is completely customizable (code does just the bare minimum), thus you can change which events trigger moving around and pressing, eg using different pointing devices, or a set of keys(arrows).

Usage:
 - Add `ONE_HAND = yes` to your **rules.mk** -->