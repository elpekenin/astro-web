---
datetime: 2023-06-05T15:00:00Z
title: "Userspace documentation #QMK"
featured: true
tags:
- qmk
ogImage: ""
---

---
# ‚ö†Ô∏è NOTE ‚ö†Ô∏è

*Any code/explanation in here may not be updated with the current state of my repo whenever you read this, bear that in mind. However, file names/location shouldn't change much and should be easy to find. Code-wise, chances are stuff is added without removing (**but perhaps moving**) the functionality explained here.*

If you are reading this, you probably know already, but just in case: The code can be found at the `pekelop` branch of my fork [here](https://github.com/elpekenin/qmk_firmware/tree/pekelop/users/elpekenin)

Code using these features can be found at the userspace itself, my [custom keyboard](https://github.com/elpekenin/qmk_firmware/tree/pekelop/keyboards/elpekenin/access) and my [keymap](https://github.com/elpekenin/qmk_firmware/tree/pekelop/keyboards/elpekenin/access/keymaps/elpekenin) for it

---

# Index

# Quantum Painter
## Drawing, and some helpers: `graphics.h`
### All assets available dynamically
See [here](#2-auto-include-assets-qp_resourcesh)

### Macros
`load_display`, `load_font` and `load_image` which:
  * Load fonts/images into RAM, using QP's API
  * Save the resources on arrays, to programatically access them
    * `qp_devices_pekenin` (avoid name collision with `qp_internal.c`)
    * `qp_fonts`
    * `qp_images`
  * Print (if QP_DEBUG is enabled) the name of the asset being loaded.

     <div style="padding-left:30px" /> Eg: "Loading ili9163 at position [0]"

### Scrolling text API ‚ú®
Using `defer_exec` to draw moving strings, similar to `qp_animate`. 

üî¥Uses `malloc`, `realloc` and `free`üî¥ to keep a copy of the string, because original text could be dropped while this is running.

**<u>Note</u>:** The state (`scrolling_text_state_t`) contains the amount of spaces to draw before repeating the string, this is currently not part of the API and gets a hardcoded value on the function's body.

  * Create a new scrolling text
  ```c
  // API is very similar to qp_drawtext[_recolor] but also takes the amount of chars to write each time, and delay between steps

  deferred_token draw_scrolling_text(painter_device_t device, uint16_t x, uint16_t y, painter_font_handle_t font, const char *str, uint8_t n_chars, uint32_t delay);

  deferred_token draw_scrolling_text_recolor(painter_device_t device, uint16_t x, uint16_t y, painter_font_handle_t font, const char *str, uint8_t n_chars, uint32_t delay, uint8_t hue_fg, uint8_t sat_fg, uint8_t val_fg, uint8_t hue_bg, uint8_t sat_bg, uint8_t val_bg);
  ``` 
  * Make a task's text longer (mainly meant for drawing long strings over XAP):
  ```c
  void stop_scrolling_text(deferred_token scrolling_token);
  ```
  * Cancel a running task
  ```c
  void stop_scrolling_text(deferred_token scrolling_token);
  ```

### Small drawing functions
There are some other functionalities here:
  - Small code to compute days, hours, minutes, seconds from `timer_read32` and drawing them on a screen (not broken into a function)
  - This function does what its name suggests, based on [#19542](https://github.com/qmk/qmk_firmware/pull/19542)
  ```c
  void draw_commit(painter_device_t device);
  ```
  - This one iterates over [`enabled_features_t`](#user_featuresh) to draw its contents. Its body is generated by [features.py](#enabled-features-featurespy)
  ```c
  void draw_features(painter_device_t device);
  ```
  
These last two functions will show latest information when called from slave side (without needing a reflash) using [data sync](#user_transactionsh) 
   
Output:
  
  ![](/content-images/qmk/features_draw.png)

## `print` on your screens: `qp_logging.h`
Again, based on @tzarc's work, this replaces the built-in function called by `print` to render each `char`. On this tweaked version, we maintain the default send-over-USB behaviour, but also keep track of it on a buffer to then draw on a display. I extended his work allowing longer lines to be stored and drawing them (when needed) with my [`scrolling API`](#scrolling-text-api-‚ú®)

The actual drawing takes place on `graphics.c`, this file simply keeps track of the text.

Usage:
  1. Configure the buffer size (or don't, and fallback to my default values)
  ```c
  #define LOG_N_LINES <Number>
  #define LOG_N_CHARS <Number>
  ```
  1. Determine the screen where to draw
  ```c
  qp_log_target_device = <your_device>;
  ```
  

## QGF-converted database (and scripts)
If you want some pre-converted QGF images, I have a collection of Material Design Icons (and the scripts to generate them from folders) in [this repo](https://github.com/elpekenin/mdi-icons-qgf)

---

# XAP
## Draw from the PC: `qp_over_xap.h`
XAP bindings that expose display-related functions over XAP.

Messages' definition can be found at `xap.hjson`

Usage:
  1. Will automatically get added if you have both XAP and Quantum Painter enabled
  2. You can disable it, even if both features are enabled
  ```makefile
  # rules.mk
  # --------
  QP_XAP = no
  ```
  3. Code relies on having the assets in the arrays mentioned on [Quantum Painter - Macros](#macros)
  4. Send XAP messages from PC to execute this code. [Here](https://github.com/elpekenin/qmk_xap) is my fork of [qmk_xap](https://github.com/qmk/qmk_xap)(official QMK's XAP client)

## Send info to the PC: `user_xap.h`
Helper functions to send information about some events to the XAP client, such as reboot/bootloader, keys being pressed or released (could make some usage stats), or [touch screen](#touch_driverh)'s state.

---

# Codegen
Generate **C** code from **Python** scripts that get run during compilation.

## 1. Enabled features: `features.py`
Defines `enabled_features_t` which is a struct containing whether some features are enabled on this compilation or not.

Usage:
  1. Tweak its configuration (if you want to) at the very top of the script
    * Add or remove elements from `FEATURES` to modify which of them are tracked
    * Use `SHORT_NAMES` to define aliases (these are only used on the `draw_features` function, not on the `struct`'s attributes names)
  2. Read the state
  ```c
  enabled_features_t get_enabled_features(void);
  ```
  3. Check a particular feature (note: all names are `lower_snake_case`)
  ```c
  if (features.rgb_matrix) {
      printf("RGB Matrix is enabled!\n");
  }
  ```

## 2. Auto-include assets: `qp_resources.py`
Creates:
  * `generated_qp_resources.h`, header that `#include`'s all QGF/QFF files found, and gets `#include`'d by `graphics.h`
  * `generated_qp_resouces.c`, defines `load_qp_resources` that calls `load_font` and `load_image` [macros](#macros) on every asset found
  * `generated_qp_resources.mk` which has the `SRC +=` lines for them

Usage: Code will locate your files at `painter/fonts` and `painter/images` on the keyboard, keymap, and userspace folders. No need to configure anything (can't be disabled either)

---

# Touchscreens: `touch_driver.h`
Custom code to interact with my XPT2046-based touchscreen modules, the code is designed such that other SPI sensors should be somewhat easy to integrate. 

This code does the bare minimum, **reads the sensor**.

Feel free to elaborate on that information: compute movements (even integrate on pointing device), detect gestures from those movements, etc. This is left as an exercise for the reader.

Usage:
  1. Enable it
  ```makefile
  # rules.mk
  # --------
  TOUCH_SCREEN = yes
  ```
  2. Configure a `touch_driver_t` according to your sensor, mine is:
  ```c
  static const touch_driver_t ili9341_touch_driver = {
      .width = _ILI9341_WIDTH,
      .height = _ILI9341_HEIGHT,
      .scale_x = 0.07,
      .scale_y = -0.09,
      .offset_x = -26,
      .offset_y = 345,
      .rotation = (ILI9341_ROTATION + 2) % 4,
      .upside_down = false,
      .spi_config = {
          .chip_select_pin = ILI9341_TOUCH_CS_PIN,
          .divisor = TOUCH_SPI_DIV,
          .lsb_first = false,
          .mode = TOUCH_SPI_MODE,
          .irq_pin = NO_PIN,
          .x_cmd = 0xD0,
          .y_cmd = 0x90
      },
  };
  touch_device_t ili9341_touch = &ili9341_touch_driver;
  ```
  3. Initialize it
  ```c
  touch_spi_init(ili9341_touch);
  ```
  4. Read
  ```c
  touch_report_t ili9341_touch_report = get_spi_touch_report(ili9341_touch, false);
  ```

  ### Note
   `scale` and `offset` values are used to calibrate the display. Reading does some mats for both coords
  ```c
  coord = (scale * raw_reading) + offset;
  ```
  With these arguments you should be able to map whichever range of values the raw data is, to: `(0, 0) - (width, height)`

  There is no code or explanation on how to do this, I simply checked what the raw data was on each of the 4 corners, to locate the two that got read as `(small_x, small_y)` and `(big_x, big_y)` discarding `(big_x, small_y)` and `(small_x, big_y)`. With these two corners i took the average of 3-5 readings and made a lineal adjustment to scale them down to the size of my display.

---

# Multi-bus SPI: `custom_spi_master.h`
"Small" changes to QMK's built-in SPI driver (abstractions over `ChibiOS`'s functions), so that we can use multiple SPI instances at the same time.

---

# "Virtual pins" to control several signals: `sipo_pins.h`
A set of macros and functions that allow using SerialIn-ParallelOut shift registers (supports daisy chaining) to control several "virtual GPIO". With this, you can generate an arbitrary amount of output signals using 3 GPIOs on the MCU (SCK, MOSI, CS).

My use-case for this is driving a multi-screen setup with fewer pins. This requires:
- [custom_spi_master](#custom_spi_masterh): one bus is used for the displays and the second one for the registers. This way, we can change CS/DC signals while talking to the display without messing communications up due to sending data on that bus.
- Patches to `qp_comms_spi.c` (or manually creating a new vtable with tons of duplication), to use the multi-bus driver instead of QMK's built-in `spi_master.h`. This code uses "tradicional" names, like `SPI_SCK_PIN`, for the screens, while the register ones prepend `REGISTER_` to them. Then arrays are created combining the two, where position(id) 0 belongs to screens and 1 to registers.

Usage:
  1. Enable it
  ```makefile
  # rules.mk
  # --------
  SIPO_PINS = yes
  ```
  2. Configure the amount of pins you will use, to allocate a buffer accordingly
  ```c
  #define N_SIPO_PINS <Number>
  ```
  3. Create your "pin" name(s) -- This is a macro, place it outside any function
  ```c
  configure_sipo_pins(<NAME_1>, <NAME_2>, ...);
  ```
  4. Control pin state
  ```c
  // Change status in buffer
  set_sipo_pin(<pin_name>, <value>);

  // Aliases
  sipo_buffer_high(<pin_name>);
  sipo_buffer_low(<pin_name>);

  // Flush state
  send_sipo_state();

  // Change state and flush it
  sipo_write_high(<pin_name>);
  sipo_write_low(<pin_name>); 
  ```

---

# Split messaging: `user_transactions.h`
Sends a `user_data_t` struct over split comms, to sync **some** information/configuration without needing to reflash slave side 
```c
// gets called upon receiving a message on slave side, to store its content
void user_data_sync_slave(uint8_t m2s_size, const void* m2s_buffer, uint8_t s2m_size, void* s2m_buffer);
// you can also define this, to run extra logic on receptions
void user_data_sync_keymap_callback(void);

// sends messages to slave periodically
void split_sync_housekeeping(uint32_t now);

// configuration needed for transactions
void transactions_init(void);
```
---

# Keylogger: `user_keylog.h`
Inspired by @drashna's code, and the `gboard` combo management, this file uses some pre-processor magic to stringify the keymap's content and get the string representation of each key. It also provides functions and macros to replace strings, eg: `"KC_SPC"` -> `" "`, this supports unicode too!!

Usage:
  1. Move your content to a new file, `layers.h`, which will be processed ***magically***

  For example
  ```c
  const uint16_t PROGMEM keymaps[][MATRIX_ROWS][MATRIX_COLS] = {
      [_BASE] = LAYOUT(KC_A, KC_B)
  };
  ```
  Would become
  ```c
  // layers.h
  // --------
  // note: in the same way as LAYOUT macro, the newlines/whitespaces dont matter
  LAYER(_BASE,
      KC_A, KC_B
  )

  // keymap.c
  // --------
  // i know this is gross ...
  #undef LAYER
  #define LAYER(layer_name, ...) [layer_name] = LAYOUT(__VA_ARGS__),
  //              may need another name here    ^^^^^^
  const uint16_t PROGMEM keymaps[][MATRIX_ROWS][MATRIX_COLS] = {
      #include KEYMAP_LAYERS_H
  };
  ```

  2. In that same file, add a dummy layer which will be used to map row/col positions to the order in which you write the keys in the macro (and vice-versa)

  For our example, that would be: 
  ```c
  // beware, counting starts at 1
  __DUMMY_LAYER(1, 2) 
  ```

  3. Configure the `KEYMAP_LAYERS_H` variable, used to locate the `layers.h` file. For me this was it:
  ```makefile
  # rules.mk
  # --------
  # this is a makefile variable
  KEYMAP_LAYERS_H = keyboards/elpekenin/access/keymaps/elpekenin/layers.h

  # this is an equivalent pre-processor macro/define
  OPT_DEFS += -DKEYMAP_LAYERS_H=\"$(KEYMAP_LAYERS_H)\"
  ```

  4. You can now get the name of a particular keycode with
  ```c
  char *get_keycode_str_at(uint8_t layer_num, uint8_t row, uint8_t column);
  ```

  5. With that function, you can do any processing after a key is pressed/released.
     - Functios to pretify string (original isn't modified, the pointer is now looking somewhere else)
     ```c
     // eg a pointer to "KC_A" would now point to "A"
     void remove_prefixes(char **str);

     // eg change "KC_LEFT" becomes "‚Üê"
     void replace_symbols(char **str);
     // iterates over an array of
     #define REPLACE(<input>, <output>)

     // same, but for shifted symbols
     void replace_mods(char **str);
     #define MOD_REPLACE(<input>, <output>, <mod_mask>)
     #define REPLACE_ALGR(<input>, <output>)
     #define REPLACE_SFT(<input>, <output>)

     // convert to lowercase based on caps and shift
     void apply_casing(char **str);
     ```

     - Functions to update the log (buffer)
     ```c
     void keylog_clear(void);

     // clear last element, aka: when backspace
     void keylog_shift_right(void);

     // add an element to the end
     void keylog_append(char *str);

     ```

     - Handle key events
     ```c
     void keylog_process(uint16_t keycode, keyrecord_t *record);
     ```

  6. My code will also change the log's color based on WPM(if enabled), you can tweak the colors (or completely get rid of them) and the WPM values at which they change by editing `graphics.c`. I didn't setup any `#define` for this 

Congratz!
![](/content-images/qmk/keylog.jpg)


<!-- # One Hand Mode (**abandoned right now**)
The goal for this feature is to add a new *RGB Matrix* animation which only lights a single LED, used as a "marker" so that you can then virtually press the selected key. This will allow for accessibility, because the direction in which the LED moves and the trigger of the press is completely customizable (code does just the bare minimum), thus you can change which events trigger moving around and pressing, eg using different pointing devices, or a set of keys(arrows).

Usage:
 - Add `ONE_HAND = yes` to your **rules.mk** -->